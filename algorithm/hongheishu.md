# 红黑树学习
## 概念 <br>
* 本质上是一种二叉查找树，在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。<br>
* 它的统计性能要好于[平衡二叉树(AVL树)](https://www.jianshu.com/p/65c90aa1236d "AVL树")
* 黑色高度：从根节点到叶节点的路径上黑色节点的个数
## 五个特性
1. 每个节点要么是黑的，要么是红的；
2. 根节点永远是黑色的；
3. 所有的叶节点都是是黑色的（只为空的节点）；
4. 每个红色节点的两个子节点一定都是黑色；
5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；
## 应用：C++ STL中的set,map等，Linux虚拟内存管理。
## 时间复杂度 (O(logn))
* 定理：一棵含有n个节点的红黑树的高度至多为2log(n+1)<br>
    1. 数学归纳法证明：h<=2log(n+1)————> n>=2^(h/2)-1<br>
    2. 黑高度大于h/2，故可证明 n>=2^bh-1<br>
    3. 数学归纳法证明之。
## 基本操作：左旋右旋
* 我的理解：<br>
    - 左旋是将一个节点左旋变成一个左节点，此时它的右节点代替原节点的位置，右节点的左孩子变为原节点的右孩子，原节点左孩子不变。（方向是向左的）<br>
    - 右旋是将一个节点右旋变为一个右节点，此时它的左节点代替原节点的位置，左节点的右孩子变为原节点的左孩子，原节点右孩子不变。（方向是向右的）<br>
## 基本操作：添加
* 第一步: 将红黑树当作一颗二叉查找树，将节点插入。
* 第二步：将插入的节点着色为"红色"。
* 第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
    - 被插入节点若为根，直接设置为黑色
    - 被插入节点父亲为黑色，无需操作
    - 被插入节点父亲为红色，操作如下<br>
    ![](https://github.com/sjtujw/data-structure-and-algorithm/raw/master/img/rb_insert.jpg)
## 基本操作：删除
* 第一步：将红黑树当作一颗二叉查找树，将节点删除。
* 第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。
